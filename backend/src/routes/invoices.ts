import express, { Request, Response } from 'express';
import { authenticate, requireAdmin } from '../middleware/auth';
import {
  getAllInvoices,
  getInvoiceById,
  getInvoiceByBookingId,
  getInvoiceByInvoiceNumber,
  createInvoice,
  regenerateInvoice,
  isInvoiceValid,
} from '../services/invoiceService';
import { InvoiceData } from '../services/invoice';
import { getTaxRate } from '../config/company';
import pool from '../config/database';
import { getInvoicePDF } from '../services/invoiceStorage';
import path from 'path';

const router = express.Router();

// All invoice routes require authentication and admin access
router.use(authenticate);
router.use(requireAdmin);

// Get all invoices with pagination
router.get('/', async (req: Request, res: Response) => {
  try {
    const page = parseInt(req.query.page as string) || 1;
    const perPage = parseInt(req.query.per_page as string) || 20;

    const result = await getAllInvoices(page, perPage);
    res.json(result);
  } catch (error: any) {
    console.error('Error fetching invoices:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get invoice by booking ID (must come before /:id route)
router.get('/booking/:bookingId', async (req: Request, res: Response) => {
  try {
    const { bookingId } = req.params;
    const invoice = await getInvoiceByBookingId(bookingId);

    if (!invoice) {
      return res.status(404).json({ error: 'Invoice not found' });
    }

    res.json(invoice);
  } catch (error: any) {
    console.error('Error fetching invoice by booking ID:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get invoice by invoice number (must come before /:id route)
router.get('/number/:invoiceNumber', async (req: Request, res: Response) => {
  try {
    const { invoiceNumber } = req.params;
    const invoice = await getInvoiceByInvoiceNumber(invoiceNumber);

    if (!invoice) {
      return res.status(404).json({ error: 'Invoice not found' });
    }

    res.json(invoice);
  } catch (error: any) {
    console.error('Error fetching invoice by number:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// POST routes must come before GET /:id route to avoid conflicts
// Manually generate invoice for a booking
router.post('/generate/:bookingId', async (req: Request, res: Response) => {
  try {
    const { bookingId } = req.params;
    const { regenerate } = req.query; // Optional: ?regenerate=true to force regeneration

    // Check if booking exists
    const bookingResult = await pool.query(
      `SELECT b.*, 
       c.first_name, c.last_name, c.email, c.phone, c.address, c.city, c.country,
       v.make, v.model, v.year,
       pl.name as pickup_location_name, pl.city as pickup_location_city,
       dl.name as dropoff_location_name, dl.city as dropoff_location_city
       FROM bookings b
       JOIN customers c ON b.customer_id = c.id
       JOIN vehicles v ON b.vehicle_id = v.id
       JOIN locations pl ON b.pickup_location_id = pl.id
       JOIN locations dl ON b.dropoff_location_id = dl.id
       WHERE b.id = $1`,
      [bookingId]
    );

    if (bookingResult.rows.length === 0) {
      return res.status(404).json({ error: 'Booking not found' });
    }

    const booking = bookingResult.rows[0];

    // Check if invoice already exists
    const existingInvoice = await getInvoiceByBookingId(bookingId);
    if (existingInvoice && regenerate !== 'true') {
      return res.status(400).json({
        error: 'Invoice already exists for this booking. Use ?regenerate=true to regenerate.',
        invoice: existingInvoice,
      });
    }

    // Get booking extras
    const extrasResult = await pool.query(
      `SELECT e.id, e.name, be.quantity, be.price
       FROM booking_extras be
       JOIN extras e ON be.extra_id = e.id
       WHERE be.booking_id = $1`,
      [bookingId]
    );

    const extras = extrasResult.rows.map((row: any) => ({
      id: row.id,
      name: row.name,
      quantity: row.quantity || 1,
      price: Number(row.price),
    }));

    // Prepare invoice data
    const invoiceData: InvoiceData = {
      invoiceNumber: '', // Will be generated by createInvoice
      invoiceDate: new Date(),
      bookingNumber: booking.booking_number,
      customerName: `${booking.first_name} ${booking.last_name}`,
      customerEmail: booking.email,
      customerPhone: booking.phone,
      customerAddress: booking.address || undefined,
      customerCity: booking.city || undefined,
      customerCountry: booking.country || undefined,
      vehicleMake: booking.make,
      vehicleModel: booking.model,
      vehicleYear: booking.year || undefined,
      pickupDate: new Date(booking.pickup_date),
      dropoffDate: new Date(booking.dropoff_date),
      pickupLocation: `${booking.pickup_location_name}${booking.pickup_location_city ? ', ' + booking.pickup_location_city : ''}`,
      dropoffLocation: `${booking.dropoff_location_name}${booking.dropoff_location_city ? ', ' + booking.dropoff_location_city : ''}`,
      basePrice: Number(booking.base_price),
      extrasPrice: Number(booking.extras_price || 0),
      discountAmount: Number(booking.discount_amount || 0),
      taxRate: getTaxRate(),
      totalPrice: Number(booking.total_price),
      extras: extras.length > 0 ? extras : undefined,
      couponCode: booking.coupon_code || undefined,
    };

    // Create or regenerate invoice
    const forceRegenerate = regenerate === 'true' && existingInvoice !== null;
    const invoice = await createInvoice(bookingId, invoiceData, forceRegenerate);

    res.status(201).json({
      message: forceRegenerate ? 'Invoice regenerated successfully' : 'Invoice generated successfully',
      invoice,
    });
  } catch (error: any) {
    console.error('Error generating invoice:', error);
    if (error.message === 'Invoice already exists for this booking') {
      return res.status(400).json({ error: error.message });
    }
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Regenerate invoice (force delete and recreate) - must come before /:id route
router.post('/regenerate/:bookingId', async (req: Request, res: Response) => {
  try {
    const { bookingId } = req.params;

    // Check if booking exists
    const bookingResult = await pool.query(
      `SELECT b.*, 
       c.first_name, c.last_name, c.email, c.phone, c.address, c.city, c.country,
       v.make, v.model, v.year,
       pl.name as pickup_location_name, pl.city as pickup_location_city,
       dl.name as dropoff_location_name, dl.city as dropoff_location_city
       FROM bookings b
       JOIN customers c ON b.customer_id = c.id
       JOIN vehicles v ON b.vehicle_id = v.id
       JOIN locations pl ON b.pickup_location_id = pl.id
       JOIN locations dl ON b.dropoff_location_id = dl.id
       WHERE b.id = $1`,
      [bookingId]
    );

    if (bookingResult.rows.length === 0) {
      return res.status(404).json({ error: 'Booking not found' });
    }

    const booking = bookingResult.rows[0];

    // Get booking extras
    const extrasResult = await pool.query(
      `SELECT e.id, e.name, be.quantity, be.price
       FROM booking_extras be
       JOIN extras e ON be.extra_id = e.id
       WHERE be.booking_id = $1`,
      [bookingId]
    );

    const extras = extrasResult.rows.map((row: any) => ({
      id: row.id,
      name: row.name,
      quantity: row.quantity || 1,
      price: Number(row.price),
    }));

    // Prepare invoice data
    const invoiceData: InvoiceData = {
      invoiceNumber: '', // Will be generated by createInvoice
      invoiceDate: new Date(),
      bookingNumber: booking.booking_number,
      customerName: `${booking.first_name} ${booking.last_name}`,
      customerEmail: booking.email,
      customerPhone: booking.phone,
      customerAddress: booking.address || undefined,
      customerCity: booking.city || undefined,
      customerCountry: booking.country || undefined,
      vehicleMake: booking.make,
      vehicleModel: booking.model,
      vehicleYear: booking.year || undefined,
      pickupDate: new Date(booking.pickup_date),
      dropoffDate: new Date(booking.dropoff_date),
      pickupLocation: `${booking.pickup_location_name}${booking.pickup_location_city ? ', ' + booking.pickup_location_city : ''}`,
      dropoffLocation: `${booking.dropoff_location_name}${booking.dropoff_location_city ? ', ' + booking.dropoff_location_city : ''}`,
      basePrice: Number(booking.base_price),
      extrasPrice: Number(booking.extras_price || 0),
      discountAmount: Number(booking.discount_amount || 0),
      taxRate: getTaxRate(),
      totalPrice: Number(booking.total_price),
      extras: extras.length > 0 ? extras : undefined,
      couponCode: booking.coupon_code || undefined,
    };

    // Regenerate invoice (force delete and recreate)
    const invoice = await regenerateInvoice(bookingId, invoiceData);

    res.status(201).json({
      message: 'Invoice regenerated successfully',
      invoice,
    });
  } catch (error: any) {
    console.error('Error regenerating invoice:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// GET routes with specific paths must come before generic /:id route
// Download invoice PDF (must come before /:id route)
router.get('/:id/download', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const invoice = await getInvoiceById(id);

    if (!invoice) {
      return res.status(404).json({ error: 'Invoice not found' });
    }

    const pdfBuffer = getInvoicePDF(invoice.file_path);

    if (!pdfBuffer) {
      return res.status(404).json({ error: 'Invoice PDF file not found' });
    }

    // Set headers for PDF download
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader(
      'Content-Disposition',
      `attachment; filename="invoice-${invoice.invoice_number}.pdf"`
    );

    res.send(pdfBuffer);
  } catch (error: any) {
    console.error('Error downloading invoice:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Check if invoice PDF is valid (must come before /:id route)
router.get('/:id/validate', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const isValid = await isInvoiceValid(id);
    
    res.json({
      invoice_id: id,
      is_valid: isValid,
      message: isValid ? 'Invoice PDF is valid' : 'Invoice PDF is missing or empty',
    });
  } catch (error: any) {
    console.error('Error validating invoice:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get invoice by ID (must be last, after all specific routes)
router.get('/:id', async (req: Request, res: Response) => {
  try {
    const { id } = req.params;
    const invoice = await getInvoiceById(id);

    if (!invoice) {
      return res.status(404).json({ error: 'Invoice not found' });
    }

    res.json(invoice);
  } catch (error: any) {
    console.error('Error fetching invoice:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;

